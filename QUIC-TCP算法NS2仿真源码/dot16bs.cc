// File:    dot16bs.cc
// Written: 09/21/2004 (for ns-2.26)
// Modified 07/27/2005 (for ns2-2.28) 

//#define GenerateSNR  

//#define RecordQoS

//#define Track_Round_Robin

//#define Track_Opportunistic

#include <string.h>
#include <stdio.h>
#include <math.h>
#include "dot16bs.h"
#include "../tools/random.h"
#include "parameters.h"


/**************************************************************
Dot16BS class
**************************************************************/
static class Dot16BSClass : public TclClass {
    public:  
                    Dot16BSClass() : TclClass("Queue/Dot16BS") {}
                    TclObject* create(int, const char*const*) {
                                return (new Dot16BS);
                    }
} class_dot16bs_queue;

/**************************************************************
Class constructor
**************************************************************/

Dot16BS::Dot16BS() //:sched_type_(2),sched_mode_(0),tttt(10)
{
    int queue_index;    // index of queue at base station for downlink
    int i;
    int pa_index;       // index for getting simulation papameters from file 
    float input_value;  // the variable for input value from file
    char str[20];       // string for getting simulation papameters from file, 
                        // length of 20 characters can be modified
    char end_line;         // variable for reading end_line character from file 
    
    FILE *fp_sched;     // file pointer to schedule statistics 
    FILE *fp_thrput;     // pointer to the file of recording throughput

    FILE *fp_sp;        // file pointer to simulation parameters
    FILE *fp_snr_dB_ns; // file pointer to signal-to-noise-ratio in dB generated by ns
    FILE *fp_snr_dB;    // file pointer to signal-to-noise-ratio in dB (from another source)
    FILE *fp_nominalsnrdb; // pointer to the file of nominal snr (dB)
    FILE *fp_Pkts0 = fopen("NumOfPkts.dat","w");
    FILE *fp_Qlen0 = fopen("QLen.dat","w");
    FILE *fdrop_rec = fopen("droprec.dat","w");
    last_record_time_ = 0.000; 

    
    //printf("TEST:Dot16BS.cc: Sched_Type = %d, Sched_Mode = %d\n", sched_type_,sched_mode_);)
    bind("SchedType", &sched_type_); 
    bind("SchedMode", &sched_mode_);
    bind("NewAlg",&NewAlg_);
    printf("Dot16BS.CC: Sched_Type = %d, Sched_Mode = %d, NewAlg_ = %d\n", sched_type_,sched_mode_,NewAlg_);
    bind_bw("BandWidth", &bandwidth_);
    printf("Dot16BS.CC: bandwidth_ = %.2f\n",bandwidth_);
    bind("Doppler",&doppler_);
    printf("Dot16BS.CC: Doppler = %.2f\n",doppler_);
    bind("RecordInterval",&record_interval_);
    printf("Dot16BS.CC: Record interval = %.4f sec\n",record_interval_);
    bind("BaseStationQueueLimit",&qmax);
    printf("Dot16BS.CC: BaseStation Queue Limit = %d\n",qmax);
    bind("NumberOfSlots",&NumOfSlots_);
    bind("SlotDuration",&SlotDuration_);
    bind("GenerateSNR",&GenerateSNR_);
	bind("pktsz",&pktsz_);
    // Check
    if (NumOfSlots_ > Num_Slot)
    {
        printf("Parameter Error: Number Of Slots exceeds Max Num Of Slots\n");
        printf("NumOfSlots_ = %d, Max_Num_Slot = %d\n", NumOfSlots_,Num_Slot);
        exit(1);
    }
    else if (SlotDuration_ != SLOT_TIME)
    {
        printf("Parameter Error: Slot Duration Error\n");
        printf("SlotDuration_ = %.8f, SLOT_TIME = %.8f",SlotDuration_ ,SLOT_TIME);
        exit(1);
    }
    printf("Dot16BS.CC: Number Of Simulation Slots = %d\n",NumOfSlots_);
    printf("Dot16BS.CC: SlotDuration_ =  %.5f ms\n",(1000*SlotDuration_));
    
    printf("snr_to_rate:\n");
    
    for (i=0; i< NUM_RATE_OPTIONS; i++)
    {
        snr_to_rate[i][1] = snr_to_rate[i][1]*(bandwidth_*SLOT_TIME);
        #if 0
        snr_to_rate[0][0] = -100;
        snr_to_rate[NUM_RATE_OPTIONS-1][0] = 1000;
        snr_to_rate[i][1] = 0.125*(bandwidth_*SLOT_TIME);
        #endif
        printf("%.8f,%.8f,%.8f\n",snr_to_rate[i][0],snr_to_rate[i][1],snr_to_rate[i][2]); 
    }
    
   


    /* Initialize new frame indicator queue */
    q_newframe = new PacketQueue;

    /* Intialization for new frame */
    flag_newframe = TRUE;      // Flag of new frame    
    flag_startframe = FALSE;   
    virtual_pkt_enqued_indicator = FALSE;
    expected_arrival_time = 2*Num_Slot*SLOT_TIME;
    Check_Slot_Start_Time = TRUE;
    Prev_Slot_Time = 0;
    
    for(queue_index = 0; queue_index < NUM_BS_QUEUES; queue_index++) {
        
        /* Initialize packet queue and 
           the average throughput for proportional fair scheduler */
        q_[queue_index]  = new PacketQueue;  
        avg_thrput[queue_index] = 1.0;
        
        /* Initialization for fragmentation */
        flag_fragment[queue_index] = FALSE;    // Flag of fragmentation 
        fragment_bytes_inqueue[queue_index] = 0;    // Fragment (bytes) left in queue    
        
        /* Initialize capacity per frame */
        //capacity_bytes[queue_index] = (int) (4.5 * 50) ;    
        
        /* Initialize number of fragment of head of line packet left in queue */    
        fragment_inqueue[queue_index] = 0;            

        /* Initialize number of scheduled packets */
        num_sched_pkt[queue_index] = 0;
    }

    sel_queue = -1;     // selected queue index 
    sel_rate  = 0.0;    // rate (spectral efficiency) of selected queue
    deq_turn_ = 0;      // dequeue turn (index) for Round-Robin scheduler
    
        
    //printf("Maximum queue length: qmax = %d, \n",qmax);
    if (GenerateSNR_ == 1)
    {
        /* Get NominalSINRdB from file */
        fp_nominalsnrdb = fopen("NominalSINRdB.txt","r");
        for(trial_index = 0; trial_index < Num_Trial; trial_index++)
        {
            for(user_index = 0; user_index < Num_User; user_index++)
            {
                fscanf(fp_nominalsnrdb, "%f\n", &input_value);
                NominalSINRdB[user_index][trial_index] = input_value;
            }
            fscanf(fp_nominalsnrdb, "\n", &end_line);
        }        
        fclose(fp_nominalsnrdb); 
        


    
        /* generate SNR by ns */
    
        /* Initialize the file for recording snr values */
        fp_snr_dB_ns = fopen("snr.txt","w");
        fprintf(fp_snr_dB_ns, "");
        fclose(fp_snr_dB_ns);

        /* Generate SNR values */
        printf("Generating SINR by ns ... \n");
        Genarate_SNR_values();
        printf("Done\n");
        exit(0);
    
    }
        
        
    
        /* Read snr_dB_value from file */
        fp_snr_dB = fopen("snr.txt","r");

        for(trial_index = 0; trial_index < Num_Trial; trial_index++){
            for(user_index = 0; user_index < Num_User; user_index++){
                for(slot_index = 0; slot_index < Num_Slot; slot_index++){

                    fscanf(fp_snr_dB, "%f ", &input_value);
                    snr_dB_value[trial_index][user_index][slot_index] = input_value;

                }   
            }
        }
        fclose(fp_snr_dB);    
        
     


    printf("\nRun simulation ... \n");
}


/**************************************************************
enque()
Enqueues a packet in the queue identified by flow ID
**************************************************************/

void Dot16BS::enque(Packet* p)
{
    int queue_index; // index of queue at base station for downlink

    double now;     // Current simulation time
    int TotalQueueSize = 0, i = 0;
    /* Get pointer to packet header */
    hdr_ip* iph = hdr_ip::access(p); 
    
    /* Determine flow ID from packet header */
    int cl = (iph->flowid()); 
    queue_index = cl;
    now = Scheduler::instance().clock();
    
    //printf("Enque: FID= %d,now = %.16f, (now/(SLOT_TIME)) = %.16f, NullCnt = %d\n\n ",
    //                    cl,now ,(now/(SLOT_TIME)),NullCnt);
    /* Check flow ID */
    /* Enqueue the packet in the appropriate queue based on flow ID */
    if (queue_index == 1000) { 

        q_newframe->enque(p);
        if(flag_startframe == TRUE && virtual_pkt_enqued_indicator == FALSE)
        {
            virtual_pkt_enqued_indicator = TRUE;
            //printf("Virtual Pkt Enqued: now = %.12f\n",now);
        }
        if(q_newframe->length() > qmax){
            q_newframe->remove(p);
            drop(p);
            printf("Dot16BS::enque(): FID = %d\n", queue_index);
        }
        
             
        return;
    }
    
     if((queue_index < 0) || (queue_index >= NUM_BS_QUEUES)){
        printf("Dot16BS::enque():Invalid Flow ID in Dot16BS: %d\n", cl);
        printf("Packet Dropped!");
        drop(p);
        return;
    }  
  

    /*if (queue_index == 1 || queue_index == 2)
    {
      printf("Enque Error, %.8f\n",now);
      exit(1);
    }*/
    /* Enqueue the packet in the appropriate queue based on flow ID */
    q_[queue_index]->enque(p);
    TotalQueueSize = 0;
    
    for (i = 0; i < NUM_BS_QUEUES; i++)
    {
        TotalQueueSize = TotalQueueSize + q_[i]->length();
    }
    
    /* If the queue length exceeds a threshold, drop the packet */
    if(TotalQueueSize > qmax){
        q_[queue_index]->remove(p);
        drop(p);
        
        FILE* fdrop = fopen("droprec.dat","a");
        fprintf(fdrop, "%d %d %.4f\n", queue_index, TotalQueueSize,now);
        fclose(fdrop);
        
        
    }   

    return;
}

/**************************************************************
deque():
Implemention of a scheduler for multiple queues
**************************************************************/

Packet* Dot16BS::deque()
{
    Packet *p, *selected_p;
    Packet *p_New;
    /* Initialize index tracking selected queue */
    sel_queue = -1;
    sel_rate  = 0.0;  
  
    double now;    
    now = Scheduler::instance().clock();
    int i;
    // dequeue a packet as an indicator to increase frame time

    /* trial_index is the integer of current simulation time over the time per trial */
    trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);
             
    /* slot_index is the time-slot offset in current trial, which is the module 
        of the total number of slots over the number of slots per trial. */
    slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);     

    /* Start new frame */
    
    if ( (flag_startframe == TRUE) ) {
     //printf("Dequing Virtual queue:now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",
                        //now ,(now/(SLOT_TIME)));
        if (virtual_pkt_enqued_indicator == FALSE) 
        {
            printf("Scheduled Virtual Packet Expected At %.12f\n",expected_arrival_time);
            p = NULL;
            if (now > expected_arrival_time)
            {
                printf("Virtual Packet Equeue Time Out:" );
                printf("now = %.16f, (now/(SLOT_TIME)) = %.16f, Expected Time = %.12f\n ",
                        now ,(now/(SLOT_TIME)),expected_arrival_time);
                exit(1);
            }
            return(p);
        }
         
        // Display dequeue turn        
        //printf("deq_turn_ = %d, \n",deq_turn_);        
             
        // Check slot index increment        
        if (slot_index == 0) {
            slot_index_last = 0;                // Initilization    
        } 
        else {
    
            // Check if increment is 1
            if ((slot_index_last + 1) != slot_index) {
                printf("\n\nError: Slot increment is not one! \n");        
                printf("last slot_index = %d, \ncurrent slot_index = %d \n",
                        slot_index_last,slot_index);      
                
                printf("now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",
                        now ,(now/(SLOT_TIME)));        
                          
                exit(1);
            }
            else {
                slot_index_last = slot_index;
            }
                
         }    

        #ifdef Track_Round_Robin
            printf("\n");                            
            printf("q_newframe->length() = %d",q_newframe->length());
            printf("\n");          
        #endif                   
        
        //printf("q_newframe->length() = %d\n",q_newframe->length()); 
        /*if (q_newframe->length() == 0) { 
            printf("Inject a new packet\n");
            p_New = PktGen();
		    q_newframe->enque(p_New);
		    printf("Length  = %d after injection\n",q_newframe->length());
		    printf("slot_index = %d\n",slot_index);
		    exit(1);
            
        }*/
        if (q_newframe->length() == 0) { 
            printf("\nq_newframe is empty! \n \nEXIT SIMULATION!! \n\n");
            printf("slot_index = %d\n",slot_index);
            exit (1);
        }
        
        //printf("Flag == TRUE, Deque FID = 1000, Time = %.14f\n",now) ;          
        
        p = q_newframe->deque(); 
        
        
        
        /*if (q_newframe->length() != 0)*/
            //exit(1);
        
        /*
        double next_frame_time = SLOT_TIME*(floor(now/SLOT_TIME)+1) + 1e-9;
        Scheduler& s = Scheduler::instance();
    
        printf("next_frame_time = %f , \n",next_frame_time);
    
        s.schedule(target_, p, next_frame_time - now );        
        */
        
        flag_startframe = FALSE ; // dequeue only one packet of q_newframe to start new frame  
        expected_arrival_time = (Num_Slot+10)*SLOT_TIME;
        Check_Slot_Start_Time = TRUE;
   
        
        Check_New_Trial();       
        
        now = Scheduler::instance().clock();

    }
    
    else { 
         /*printf("Dequing DATA queue:now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",
                       now ,(now/(SLOT_TIME)));*/
         if (Check_Slot_Start_Time == TRUE)
         {
             /*FILE *pFileRecordTime;
             pFileRecordTime = fopen("SlotTime.txt","a");
             fprintf(pFileRecordTime,"%.16f",now);
             fprintf(pFileRecordTime,"\n");
             fclose(pFileRecordTime);*/
             //printf("Time Recorded\n");
             if ((abs(now - Prev_Slot_Time - SLOT_TIME) >= (0.000001*SLOT_TIME))&&(now != 0))
             {
                printf("Clock Error: now = %.16f, Prev_Slot_Time = %.16f\n",now,Prev_Slot_Time);
                //printf("(abs((now - Prev_Slot_Time - SLOT_TIME)/SLOT_TIME)= %.16f\n", CLOCK_ERROR_THRESH);
                exit(1);
             }
             Prev_Slot_Time = now;
             Check_Slot_Start_Time = FALSE;
         }
         //printf("Flag == FALSE, Deque FID = 0/1/2, Time = %.14f\n",now) ;
         //bind_bw("bandwidth_", &bandwidth_);
         //printf("Dot16BS.CC: bandwidth_ = %.16f\n",bandwidth_);
        /* Pick Scheduling Algorithm */
        if(sched_type_ == ROUND_ROBIN){
            p = round_robin_scheduler();
        }

        if(sched_type_ == OPPORTUNISTIC){       
            p = opportunistic_scheduler();
        }
        //Record 
        if (now - last_record_time_ >= record_interval_)
        {
            FILE *fp_Pkts = fopen("NumOfPkts.dat","a+");
            FILE *fp_Qlen = fopen("QLen.dat","a+");
            for (i = 0; i < Num_User; i++)
            {
                fprintf(fp_Pkts,"%d  ",num_sched_pkt[i]);
                fprintf(fp_Qlen,"%d  ",q_[i]->length());
            
            }
            fprintf(fp_Pkts,"%.4f\n", now);
            fclose(fp_Pkts);
            fprintf(fp_Qlen,"%.4f\n", now);
            fclose(fp_Qlen);
            last_record_time_ = now;
        }
        

    } // ( (flag_newframe == TRUE) && (flag_startframe == TRUE))
    #if 1
	if (flag_startframe == TRUE) {
        virtual_pkt_enqued_indicator = 0;
        expected_arrival_time = now + 1e-8;
        p_New = PktGen();
        //Dot16BS *p_Dot16;
        //p_Dot16 = this;
		if (p != NULL)
		{
            this->enque(p_New);
            
            
            //printf("P!=NULL; Enque Imediately");
            //printf("now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",now ,(now/(SLOT_TIME)));
        }
        else
        {
             Scheduler &s = Scheduler::instance();
		     s.schedule(this, p_New, 1e-9);
		     
		     //printf("P = NULL, Schedule an enque Event: %d",NullCnt);
		     //printf("now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",now ,(now/(SLOT_TIME)));
                        
		     //printf("NullCnt = %d\n", NullCnt);
		     //p_Dot16->enque(p_New);
		     
		     
		    // printf("Enque Scheduled\n");
		 }

	}
    #endif
    //printf("NullCnt = %d\n", NullCnt);
    //printf("NonNullCnt = %d\n", NonNullCnt);
    return(p);
    
}

/******************************************************************
Opportunistic Scheduler: uses a metric derived from
the channel conditions of all users augmented with 
fairness criteria to schedule users
******************************************************************/

Packet* Dot16BS::  opportunistic_scheduler()
{
    Packet *p, *selected_p; // Pointer to return and selected packet
    float max_metric; // Maximum scheduling metric
    //float metric;     // Metric for current user
    int pkt_dequed;   // Flag to indicate if a packet was dequeued
    int queue_index;  // Index to loop over users/queues
    int i;  // loop index
    double now;             // Current simulation time

    double avg_thr_next; // avgerage throughput of next slot
    float snr_dB;        // signal-to-noise-ratio (dB)
        
    float req_rate[NUM_BS_QUEUES]; // reqest rate for PROPORTIONAL_FAIR scheduler   
    int QueueLen;    
    //float costnum[7] = { 2.0, 6.0, 1.0, 3.0, 9.0, 5.0, 7.0 };
        
    now = Scheduler::instance().clock();
    
    /* Initial varialble values */
    selected_p = 0;
    max_metric = -1e16;
    pkt_dequed = FALSE;    
    
    int index_sort[NUM_BS_QUEUES];    
    float metric_sort[NUM_BS_QUEUES];    
    int search_index;      
    int start_index;  // start index of search 
    int search_flag;  // Boolean flag indicating search termination

    int packetsize;
    
    /* trial_index is the integer of current simulation time over the time per trial */
    trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);

    /* slot_index is the time-slot offset in current trial, which is the module 
       of the total number of slots over the number of slots per trial. */
    slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);
    
if (flag_newframe == TRUE) {    

    /* Compute metric */  
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){
    
        /* Look to see if there are any packets left in this queue.*/
        //p = q_[queue_index]->head();

        // Get snr (dB) value from matrix
        snr_dB = snr_dB_value[trial_index][queue_index][slot_index];//lzq: given Trial_index and slot_index, find Max SNR
                                
        if(sched_mode_ == MAX_SNR) {
         
                sel_rate = 0.0;
                for(i=0;i<NUM_RATE_OPTIONS;i++){
            
                    if(snr_dB > snr_to_rate[i][0]) {//lzq: Find Max SNR
                        sel_rate = (float) (snr_to_rate[i][1]);  
                        mode_record[trial_index][queue_index][slot_index] = i+1;
                    }

                }   
                if (sel_rate == 0.0) {           
                    mode_record[trial_index][queue_index][slot_index] = 0;
                }
 
                capacity_bytes[queue_index] = 
                     (int) sel_rate; // (bits/slot)
                    //sel_rate * FRAME_TIME ;
                    //(int) (sel_rate * 50) ;
                    //100;            
                    
                capacity_record[trial_index][queue_index][slot_index] = capacity_bytes[queue_index];
                         
            metric[queue_index] = pow(10.0, (snr_dB/10.0));//lzq: 10^(SNR/10)
            
            // variables for sorting
            metric_sort[queue_index] = metric[queue_index];
            index_sort[queue_index] = queue_index;
                        
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    metric_record[trial_index][queue_index][slot_index] = metric[queue_index];
                    /*
                    printf("metric_record[%d][%d][%d] = %f, \n",
                        trial_index,queue_index,slot_index,
                        metric_record[trial_index][queue_index][slot_index]);
                    */    
                }       
                                        
        }                   
        else if(sched_mode_ == MAX_RELATIVE_SNR) {
            //metric = snr_dB - NominalSINRdB[queue_index][trial_index];
        }
        else if(sched_mode_ == PROPORTIONAL_FAIR) {

                sel_rate = 0.0;
                for(i=0;i<NUM_RATE_OPTIONS;i++){
            
                    if(snr_dB > snr_to_rate[i][0]) {
                        sel_rate = (float) (snr_to_rate[i][1]);  
                        mode_record[trial_index][queue_index][slot_index] = i+1;
                    }

                }   
                if (sel_rate == 0.0) {           
                    mode_record[trial_index][queue_index][slot_index] = 0;                
                }
 
                capacity_bytes[queue_index] = 
                    (int) sel_rate; // (bytes/slot)
                    //sel_rate * FRAME_TIME ;
                    //(int) (sel_rate * 50) ;
                    //100;           
                    
                capacity_record[trial_index][queue_index][slot_index] = capacity_bytes[queue_index];
                
                /* If capacity_bytes is less than a threshold, set metric as zero. */ 
            if (capacity_bytes[queue_index] < 1e-5) {
            
                metric[queue_index] = 0.0;
            
                /* If average throughput is less than a threshold and approaches zero, 
                set metric as a high value */    
            } else if (avg_thrput[queue_index] < 1e-8) {
            
                metric[queue_index] = 1e8;

                //printf("avg_thrput approaches 0, user_index = %d,  trial_index = %d, slot_index = %d,  \n", 
                  //                queue_index,trial_index,slot_index);
                //printf("avg_thrput = %.16f, \n\n", avg_thrput[queue_index]); 
                //exit(1);
                              
            } else {
            
                metric[queue_index] = ( (float) capacity_bytes[queue_index])
                                            /(avg_thrput[queue_index]);  
                
                
                //metric[queue_index] = costnum[queue_index];
                
            }
				
			QueueLen = q_[queue_index]->length();
            if (QueueLen <= 10)
            {QueueLen = 10;}
            if (NewAlg_ == 1)
            {

                
				//printf("%d %.4f AA",queue_index, metric[queue_index]);
			    metric[queue_index] = metric[queue_index]*QueueLen;
			    //printf("%d %.4f BB\n",queue_index, metric[queue_index]);
            }
			else if (NewAlg_ == 2)
            {

                
				metric[queue_index] = ((float) capacity_bytes[queue_index])*((float) QueueLen);	 

            }
            
            // variables for sorting
            metric_sort[queue_index] = metric[queue_index];
            index_sort[queue_index] = queue_index;
                            
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    metric_record[trial_index][queue_index][slot_index] = metric[queue_index];
                    /*
                    printf("metric_record[%d][%d][%d] = %f, \n",
                        trial_index,queue_index,slot_index,
                        metric_record[trial_index][queue_index][slot_index]);
                    */    
                }                              
                            
        }        
        else{
            printf("Invalid Scheduler Mode for Opportunistic Scheduling\n");
            exit(1);
        }

        
       
        
    } // end for
      
      
      
    #ifdef Track_Opportunistic
    /*
    printf("\n Before sort, ");       
    printf("\n metric, ");       
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%.1f, ",metric[queue_index]);
                        
    }                    
    printf("\n metric_sort, ");                    
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%.1f, ",metric_sort[queue_index]);            
                        
    }               
    
    printf("\n index_sort, ");
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%d, ",index_sort[queue_index]);                              

    }  
    */
    #endif         
    
    /* Sort metric */
        
    int j;         
    float temp_metric;
    int temp_index;

    for(i = 0; i < NUM_BS_QUEUES - 1; i++){
        for(j = NUM_BS_QUEUES - 1; j >= i+1; j--){

            if ( metric_sort[j-1] < metric_sort[j] ) { 

                temp_metric = metric_sort[j];
                metric_sort[j] = metric_sort[j-1];
                metric_sort[j-1] = temp_metric;  
                
                temp_index = index_sort[j];
                index_sort[j] = index_sort[j-1];
                index_sort[j-1] = temp_index;

            }

        }
    }        
    
    #ifdef Track_Opportunistic
    /*
    printf("\n\n After sort, ");       
    printf("\n metric, ");       
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%.1f, ",metric[queue_index]);
                        
    }                    
    printf("\n metric_sort, ");                    
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%.1f, ",metric_sort[queue_index]);            
                        
    }               
    
    printf("\n index_sort, ");
    for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){

            printf("%d, ",index_sort[queue_index]);                              

    }  
    */
    #endif 
    
    /* Search non-empty queue */
    

    
    // Initial deq_turn_
    search_index = 0;  // seleted index is set as the first sort index 
    deq_turn_ = index_sort[search_index];      // dequeue turn is the queue index pointed by search_index
    start_index = search_index;
    search_flag = FALSE;    

    capacity_bytes_deq_turn_ = capacity_bytes[deq_turn_];       
      
   
            #ifdef Track_Opportunistic
            
                /* Check the head of the queue indexed by deq_turn_ */
                p = q_[deq_turn_]->head();
                    
                printf("\n\n");
            
                printf("Initial deq_turn_ search: \n"); 
                printf ("1.now = %.16f\n",now);
                //printf("slot_index = %d, \n",slot_index);

                printf("search_index = %d, \n",search_index);
                printf("deq_turn_ = %d, \n",deq_turn_);

                printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                //printf("flag_newframe = %d, \n",flag_newframe);

                printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
                
                //printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
                printf("\nStart deq_turn_ search: \n");             
                                
            #endif
                      
    while( (search_flag == FALSE) && (flag_newframe == TRUE) ) {
    
        /* Check the head of the queue indexed by deq_turn_ */
        p = q_[deq_turn_]->head();
        
        /* Check queue length to find the available queue.
            which can dequeue packet */
            
        if ( (q_[deq_turn_]->length() == 0)  ) {
                      
            //printf("\nflag_newframe = %d, \n",flag_newframe);
            //printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
        
            /* Go to next queue if
             - packet was not found OR
             - packet was found and this round is terminated */

            #ifdef Track_Opportunistic
                printf("\n");
                
                printf("slot_index = %d, \n",slot_index);
                printf("search_index = %d, \n",search_index);
                printf("deq_turn_ = %d, \n",deq_turn_);                
                printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                //printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
            
                printf("queue[%d] empty,  \nstart search: search_index = %d, ",
                       deq_turn_, search_index);
                printf("deq_turn_ = %d, --> \n",deq_turn_);
            #endif
            
            //deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);
            search_index = ((search_index + 1) % NUM_BS_QUEUES);  
            deq_turn_ = index_sort[search_index];  // dequeue turn is the queue index pointed by search_index                      
            
            capacity_bytes_deq_turn_ = capacity_bytes[deq_turn_];       
                        
            #ifdef Track_Opportunistic
    
                printf("search_index = %d, ",search_index);
                printf("deq_turn_ = %d, \n",deq_turn_);
                printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
                
            #endif
                
            /* If the search wraps back to the starting point, 
                terminate search and start new frame */
                
            if(search_index == start_index) {
                /*printf("All Queues are empty: now = %.16f, (now/(SLOT_TIME)) = %.16f, \n ",
                        now ,(now/(SLOT_TIME)));*/
                #ifdef Track_Opportunistic
                    printf("\n");
                    printf("The search wraps back to the starting point, \n");
                    printf("terminate search and start new frame. \n");
                    printf ("12. now = %.16f\n",now);
                #endif 

                                
                search_flag = TRUE;
                flag_newframe = TRUE ;     flag_startframe = TRUE ;   
            }   
        }    

        /* If find available queue */
        else {
            
            /* Queue is non-empty, hence mark search flag */
            search_flag = TRUE;    
            flag_newframe = FALSE ; 
            /*printf("Queue is non-empty: now = %.16f, (now/(SLOT_TIME)) = %.16f : ",
                        now ,(now/(SLOT_TIME)));
            printf("capacity_bytes[0,1,2] = %d, %d, %d",  capacity_bytes[0],capacity_bytes[1],capacity_bytes[2]);             
            printf("metric  = %.5f, %.5f, %.5f",  metric[0],metric[1],metric[2]); 
            printf("index_sort  = %d, %d, %d",  index_sort[0],index_sort[1],index_sort[2]); 
            
            printf(" q_[%d]->length() = %d o \n", deq_turn_,q_[deq_turn_]->length());*/
            #ifdef Track_Opportunistic
               
                printf("Queue is non-empty, search_flag = TRUE, \n"); 
				printf ("2.now = %.16f\n",now);
                printf("search_index = %d, \n",search_index);
                printf("deq_turn_ = %d, \n",deq_turn_);            
                printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                printf("\nStart transmission: \n");
            
            #endif 
                        
        }

    } // while(search_flag == FALSE)
                
} // if (flag_newframe == TRUE)       

        /* Transmission for deq_turn_ */
       //else 
		if (q_[deq_turn_]->length()>0)
         {            
            
            /* Determine packet size of head of line packet */
            
            if (flag_fragment[deq_turn_] == TRUE) {
                // packet size is the fragment of head of line packet in queue
                packetsize = fragment_inqueue[deq_turn_] ;
            }
            else {
                /* Set 'selected packet' pointer to the head of queue */
                p = q_[deq_turn_]->head();

                /* Get pointer to packet header */
                hdr_cmn* cmnh = hdr_cmn::access(p);

                /* Determine packetsize from packet header in bytes */
                packetsize = (cmnh->size());
				//if (packetsize != pktsz_) 
				//{printf("{Packet Size = %d at %.4f}--",packetsize,now);}
            }                        
            //printf("capacity_bytes[%d] = %d VS packetsize = %d :: Now = %.16f\n", deq_turn_,capacity_bytes[deq_turn_],packetsize,now);

            /* If capacity is greater than packet size, then dequeue and
                update remainder capacity */
                
            if (capacity_bytes[deq_turn_] >= packetsize) {
                
                #ifdef Track_Opportunistic
                    printf("\n");
                    
                    printf("slot_index = %d, \n",slot_index);
                    printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());printf ("3.now = %.16f\n",now);
                    if (flag_fragment[deq_turn_] == TRUE) {
                        printf("HOL is a fragment, \n");
                        }
                    else {
                        printf("HOL is a whole packet, \n");
                    }
                    printf("capacity_bytes[%d] = %d >= packetsize = %d, \n",
                            deq_turn_,capacity_bytes[deq_turn_],packetsize);
                #endif

                capacity_bytes[deq_turn_] = capacity_bytes[deq_turn_] - packetsize;
                
                flag_fragment[deq_turn_] = FALSE ;
                fragment_inqueue[deq_turn_] = 0 ;

                p = q_[deq_turn_]->deque();
                //printf("q_[%d]->deque(), \t",deq_turn_);
                

                if (trial_index < Num_Trial && slot_index < Num_Slot) {
                num_sched_pkt[deq_turn_] ++ ;
                //printf("num_sched_pkt[%d] = %d,\n",deq_turn_,num_sched_pkt[deq_turn_]);
                }
                
                /* Set variable to indicate that a packet was dequed */
                pkt_dequed = TRUE;
                /*printf("q_[%d]->length() = %d and",deq_turn_, q_[deq_turn_]->length()); 
                printf("Pkt_dequed is set TRUE: now = %.16f, (now/(SLOT_TIME)) = %.16f\n ",
                        now ,(now/(SLOT_TIME)));*/

                #ifdef Track_Opportunistic
                    printf("Dequeue, capacity_bytes[%d] = capacity_bytes[%d] - packetsize = %d, \n",
                                    deq_turn_,deq_turn_,capacity_bytes[deq_turn_]);
                    printf ("4.now = %.16f\n",now);
                    printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                #endif
                

                /* If queue becomes empty, start a new frame  */
                if (q_[deq_turn_]->length() == 0) {

                    flag_newframe = TRUE ;     flag_startframe = TRUE ;
                    /* printf("flag_startframe is set TRUE(All pkts are Dequed): now = %.16f, (now/(SLOT_TIME)) = %.16f : ",
                        now ,(now/(SLOT_TIME)));*/
                    #ifdef Track_Opportunistic
                        printf("\nqueue[%d] empty after dequeue, ",deq_turn_);
                        printf ("5.now = %.16f\n",now);
                    #endif

                    //deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);

                    #ifdef Track_Opportunistic
                        printf("deq_turn_ = %d, \n\n",deq_turn_);
                    #endif

                }
                else {
                    flag_newframe = FALSE ;    flag_startframe = FALSE ;
                }

            } // if (capacity_bytes[deq_turn_] >= packetsize)
            
            /* If capacity is less than packet size, transmit fragment of head of line packet
                and start a new frame. But, do not dequeue this packet */

            else if ( (0 <= capacity_bytes[deq_turn_] ) &&
                           (capacity_bytes[deq_turn_] < packetsize) ) {
                
                 /*printf("capacity_bytes[%d] = %d < packetsize = %d:",
                                deq_turn_,capacity_bytes[deq_turn_],packetsize); 
                 printf("now = %.8f...\n",now);*/
                /* If capacity is greater than zero, set fragment; otherwise set non-fragment */

                if (capacity_bytes[deq_turn_] > 0) {

                    #ifdef Track_Opportunistic
                        printf("\n");
                        printf("slot_index = %d, \n",slot_index);
                        printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                        printf ("6.now = %.16f\n",now);
                        if (flag_fragment[deq_turn_] == TRUE) {
                            printf("HOL is a fragment, \n");
                        }
                        else {
                          printf("HOL is a whole packet, \n");
                        }
                        printf("capacity_bytes[%d] = %d < packetsize = %d, \n",
                                deq_turn_,capacity_bytes[deq_turn_],packetsize);
                    #endif
                    //printf("capacity_bytes[deq_turn_] = %d : now = %.8f\n",capacity_bytes[deq_turn_],now);
                    fragment_inqueue[deq_turn_] = packetsize - capacity_bytes[deq_turn_] ;
                    flag_fragment[deq_turn_] = TRUE ;
                    capacity_bytes[deq_turn_] = 0; // capacity becomes zero
                    
                    #ifdef Track_Opportunistic
                        printf("flag_fragment[%d] = TRUE \n", deq_turn_);
                        printf("fragment_inqueue[%d] = packetsize - capacity_bytes[%d] = %d, \n",
                                    deq_turn_,deq_turn_,fragment_inqueue[deq_turn_]);
                    #endif
                }

                /* If capacity becomes zero after previous dequeue, set non-segment */

                else if (capacity_bytes[deq_turn_] == 0) {

                    #ifdef Track_Opportunistic
                        printf("\n");
                        printf("slot_index = %d, \n",slot_index);
                        printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                        printf ("7.now = %.16f\n",now);
                        if (flag_fragment[deq_turn_] == TRUE) {
                            printf("HOL is a fragment, \n");
                        }
                        else {
                          printf("HOL is a whole packet, \n");
                        }
                    #endif

                    //fragment_inqueue[deq_turn_] = 0 ;
                    //flag_fragment[deq_turn_] = FALSE ;

                    #ifdef Track_Opportunistic
                        printf("capacity_bytes[%d] = %d < packetsize = %d, \n",
                                deq_turn_,capacity_bytes[deq_turn_],packetsize);
                        printf("flag_fragment[%d] = FALSE \n", deq_turn_);
                        printf("fragment_inqueue[%d] = %d, \n",
                                deq_turn_,fragment_inqueue[deq_turn_]);
                    #endif

                }

                flag_newframe = TRUE ;      flag_startframe = TRUE ;

                #ifdef Track_Opportunistic
                    //printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                    //printf("deq_turn_ = %d --> ",deq_turn_);
                #endif

                //deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);

                #ifdef Track_Opportunistic
                    //printf("deq_turn_ = %d, \n",deq_turn_);
                #endif

            }
            else {

                /* If capacity is less than zero, report error */

                printf("\n\n");
                printf("Error: capacity_bytes < 0");
                exit(1);
            }

        }  // Transmission for selected deq_turn_ 
        
        
        /* Update statistics */

        if (flag_newframe == TRUE) {
        
            /* Update average throughput for non deq_turn_ queue */
            for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){
            
                if (queue_index != deq_turn_) {

                    #ifdef Track_Opportunistic
                        printf("avg_thrput[%d] = %f, ",queue_index,avg_thrput[queue_index]);
                        printf ("8.now = %.16f\n",now);
                    #endif 
                    
                    avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[queue_index]);
                    avg_thrput[queue_index] = avg_thr_next;
                    avg_thrput_record[trial_index][queue_index][slot_index] = avg_thr_next;
                    
                    #ifdef Track_Opportunistic
                        printf("-->avg_thrput[%d] = %f, \n",queue_index,avg_thrput[queue_index]);
                    #endif
                }
                        
            }
           

            /* Update throughput for deq_turn_ */                    

            if (1) {
               //C1++;
               //printf("C1 = %d\n",C1);
               #ifdef Track_Opportunistic 
               printf("\nsearch_index != start_index \n");
               printf ("9.now = %.16f\n",now);
               printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
               printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
               printf("avg_thrput[%d] = %f, ",deq_turn_,avg_thrput[deq_turn_]);
               #endif 
                
               avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[deq_turn_]
                  +  EXP_THROUGHPUT_PARAM*(capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]) );
               avg_thrput[deq_turn_] = avg_thr_next;   // average throughput in the next slot
               avg_thrput_record[trial_index][deq_turn_][slot_index] = avg_thr_next;
                
               #ifdef Track_Opportunistic 
                    printf("--> avg_thrput[%d] = %f, \n\n",deq_turn_,avg_thrput[deq_turn_]);
               #endif                
            
                /* save schedule statistics in matrix */
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    sched_stat[trial_index][slot_index][0] = now;
                    sched_stat[trial_index][slot_index][1] = trial_index;
                    sched_stat[trial_index][slot_index][2] = slot_index;
                    sched_stat[trial_index][slot_index][3] = deq_turn_;
                    sched_stat[trial_index][slot_index][4] = 
                        (capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]);                    
                    sched_stat[trial_index][slot_index][5] = capacity_bytes_deq_turn_;
                    sched_stat[trial_index][slot_index][6] = avg_thrput[deq_turn_];
                    sched_stat[trial_index][slot_index][7] = metric[deq_turn_];                
                    sched_stat[trial_index][slot_index][8] = 
                            mode_record[trial_index][deq_turn_][slot_index];                            
                }
                
            }
            else {
                //C2++;
               //printf("C2 = %d\n",C2);
                #ifdef Track_Opportunistic
                printf("\nsearch_index == start_index \n");printf ("10.now = %.16f\n",now);
                printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
                printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
                printf("avg_thrput[%d] = %f, ",deq_turn_,avg_thrput[deq_turn_]);
                #endif 
                
                avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[deq_turn_]);
                avg_thrput[deq_turn_] = avg_thr_next;   // average throughput in the next slot
                avg_thrput_record[trial_index][deq_turn_][slot_index] = avg_thr_next;
                
                #ifdef Track_Opportunistic
                printf("--> avg_thrput[%d] = %f, \n\n",deq_turn_,avg_thrput[deq_turn_]);            
                #endif
                
                /* save schedule statistics in matrix */
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    sched_stat[trial_index][slot_index][0] = now;
                    sched_stat[trial_index][slot_index][1] = trial_index;
                    sched_stat[trial_index][slot_index][2] = slot_index;
                    sched_stat[trial_index][slot_index][3] = -1;
                    sched_stat[trial_index][slot_index][4] = 
                        (capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]);                    
                    sched_stat[trial_index][slot_index][5] = capacity_bytes_deq_turn_;
                    sched_stat[trial_index][slot_index][6] = avg_thrput[deq_turn_];
                    sched_stat[trial_index][slot_index][7] = metric[deq_turn_];  
                    sched_stat[trial_index][slot_index][8] = 
                            mode_record[trial_index][deq_turn_][slot_index];                                    
                }
                
            }
        }   
        

                #ifdef Track_Opportunistic
                    printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);printf ("11.now = %.16f\n",now);
                    printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
                #endif        

        //printf("C1 = %d ; C2 = %d\n",C1,C2);
        
        /* Return null pointer if packet is not dequeued */
        if(pkt_dequed == FALSE)
        {
           p = 0;
        }

        return(p);
        
          
}

/*****************************************************************
round_robin_scheduler()
*****************************************************************/

Packet* Dot16BS::round_robin_scheduler(){
    Packet *p;        // Pointer to return packet
    int queue_index;  // Index to loop over users/queues
    double now;       // Current simulation time
    int i;            // loop index
    
    float snr_dB;    
    
    int start_index;  // index of queue where RR search starts
    int search_flag;  // Boolean flag indicating search termination
    int pkt_dequed;   // Flag to indicate if a packet was dequeued
    int packetsize;
        
    start_index = deq_turn_;
    search_flag = FALSE;    
    pkt_dequed = FALSE;
    
    double avg_thr_next;
    
    now = Scheduler::instance().clock();    

    /* trial_index is the integer of current simulation time over the time per trial */
    trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);
             
    /* slot_index is the time-slot offset in current trial, which is the module 
    of the total number of slots over the number of slots per trial. */
    slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);  
                        
            
    /* Determine current capacity */
    if (flag_newframe == TRUE) 
    {
            
        /* Determine selected rate */     
  
        for(queue_index = 0; queue_index < NUM_BS_QUEUES; queue_index++) 
        {
              
            snr_dB = snr_dB_value[trial_index][queue_index][slot_index];
 
            sel_rate = 0.0;
            for(i=0;i<NUM_RATE_OPTIONS;i++)
            {
                
                /*
                            if(snr_dB > snr_to_rate[i][0])
                            sel_rate = (float) (snr_to_rate[i][1]);    
                            }                
                            */
                
               if(snr_dB > snr_to_rate[i][0]) 
               {
                        sel_rate = (float) (snr_to_rate[i][1]);  
                        mode_record[trial_index][queue_index][slot_index] = i+1;

               }

             }   
             if (sel_rate == 0.0) 
             {           
                    mode_record[trial_index][queue_index][slot_index] = 0;                
             }                
                
             capacity_bytes[queue_index] = (int) sel_rate; // (bits/slot)
                    //sel_rate * FRAME_TIME ;
                    //(int) (sel_rate * 50) ;
                    //(int) (4.5 * 50) ;
                    
             capacity_record[trial_index][queue_index][slot_index] = capacity_bytes[queue_index];
                    
       }     
          
       capacity_bytes_deq_turn_ = capacity_bytes[deq_turn_];       
          
    }
                                    
                        
    while(search_flag == FALSE){
    
        /* Check the head of the queue indexed by deq_turn_ */
        p = q_[deq_turn_]->head();
        
        //printf("\nflag_newframe = %d, \n",flag_newframe);
        //printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
        
        /* Check queue length and capacity to find the available queue.
            which can dequeue packet */
            
            
        if ( ( (q_[deq_turn_]->length() == 0) | (capacity_bytes[deq_turn_] == 0) ) 
            && (flag_newframe == TRUE) ) {
        
        /*
        if (  (q_[deq_turn_]->length() == 0)  && (flag_newframe == TRUE) ) {
        */
                      
            /* Go to next queue if
             - packet was not found OR
             - packet was found and this round is terminated */

            #ifdef Track_Round_Robin
                printf("\n");
             
                printf("slot_index = %d, \n",slot_index);
                printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
            
                printf("queue[%d] empty or capacity_bytes[%d] is zero  \nstart search: deq_turn_ = %d, --> ",
                       deq_turn_,deq_turn_, deq_turn_);
            #endif
            
            deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);
            
            #ifdef Track_Round_Robin
                printf("deq_turn_ = %d, \n",deq_turn_);
            #endif
                
            /* If the search wraps back to the starting point, 
                terminate search and start new frame */
            if(deq_turn_ == start_index) {

                #ifdef Track_Round_Robin
                    printf("\n");
            
                    printf("The search wraps back to the starting point, \n");
                    printf("terminate search and start new frame. \n");
                #endif 
                                
                search_flag = TRUE;
                flag_newframe = TRUE ;     flag_startframe = TRUE ;   
                
                int flag_skip = TRUE;
            }   
            else {
            
                int flag_skip = FALSE;
            
            }
        }    
     
        
        /* If find available queue */
        else {
            
            /* Queue is non-empty and capacity is non-zero, hence mark search flag */            
            search_flag = TRUE;                         

            /* Determine packet size of head of line packet */
            
            if (flag_fragment[deq_turn_] == TRUE) {
                // fragment of head of line packet in queue
                packetsize = fragment_inqueue[deq_turn_] ; 
            }
            else {            
                /* Set 'selected packet' pointer to head of selected queue */                
                p = q_[deq_turn_]->head();
            
                /* Get pointer to packet header */
                hdr_cmn* cmnh = hdr_cmn::access(p);
    
                /* Determine packetsize from packet header in bytes */
                packetsize = (cmnh->size()); 
				if (packetsize != pktsz_) 
				{printf("{Packet Size = %d at %.4f}--",packetsize,now);}

            }
                        
            /* If capacity is greater than packet size, then dequeue and 
                update remainder capacity */
                
            if (capacity_bytes[deq_turn_] >= packetsize) {

                #ifdef Track_Round_Robin
                    printf("\n");    
                    printf("slot_index = %d, \n",slot_index);
                    printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                    if (flag_fragment[deq_turn_] == TRUE) {
                        printf("HOL is a fragment, \n");
                        }
                    else {
                        printf("HOL is a whole packet, \n");
                    }            
                    printf("capacity_bytes[%d] = %d >= packetsize = %d, \n",
                            deq_turn_,capacity_bytes[deq_turn_],packetsize);
                #endif
    
                capacity_bytes[deq_turn_] = capacity_bytes[deq_turn_] - packetsize;
                flag_fragment[deq_turn_] = FALSE ;
                fragment_inqueue[deq_turn_] = 0 ;

                p = q_[deq_turn_]->deque();  
                //printf("q_[%d]->deque(), \t",deq_turn_);

                num_sched_pkt[deq_turn_] ++ ;
                //printf("num_sched_pkt[%d] = %d,\n",deq_turn_,num_sched_pkt[deq_turn_]);
                 
                /* Set variable to indicate that a packet was dequed */
                pkt_dequed = TRUE;

                #ifdef Track_Round_Robin
                    printf("Dequeue, capacity_bytes[%d] = capacity_bytes[%d] - packetsize = %d, \n",
                                    deq_turn_,deq_turn_,capacity_bytes[deq_turn_]);
                    printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                #endif
                    
                /* If queue becomes empty, start a new frame for next queue */
                if (q_[deq_turn_]->length() == 0) {
                
                    flag_newframe = TRUE ;     flag_startframe = TRUE ;

                    #ifdef Track_Round_Robin
                        printf("\nqueue[%d] empty after dequeue, deq_turn[%d] --> ",deq_turn_,deq_turn_);
                    #endif
                    
                    deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);
                    
                    #ifdef Track_Round_Robin
                        printf("deq_turn_ = %d, \n\n",deq_turn_);
                    #endif
                                                
                }             
                else {
                    flag_newframe = FALSE ;    flag_startframe = FALSE ;
                }                
         
            } // if (capacity_bytes[deq_turn_] >= packetsize)

            /* If capacity is less than packet size, transmit fragment of head of line packet 
                and start a new frame for next queue. But, do not dequeue this packet */

            else if ( (0 <= capacity_bytes[deq_turn_] ) && 
                           (capacity_bytes[deq_turn_] < packetsize) ) {

                /* If capacity is greater than zero, set fragment; otherwise set non-fragment */
                
                if (capacity_bytes[deq_turn_] > 0) {  
                   
                    #ifdef Track_Round_Robin
                        printf("\n");
                        printf("slot_index = %d, \n",slot_index);
                        printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                        if (flag_fragment[deq_turn_] == TRUE) {
                            printf("HOL is a fragment, \n");
                        }
                        else {
                          printf("HOL is a whole packet, \n");
                        }                
                        printf("capacity_bytes[%d] = %d < packetsize = %d, \n",
                                deq_turn_,capacity_bytes[deq_turn_],packetsize);
                    #endif
                            
                    fragment_inqueue[deq_turn_] = packetsize - capacity_bytes[deq_turn_] ;
                    flag_fragment[deq_turn_] = TRUE ;                    

                    #ifdef Track_Round_Robin
                        printf("flag_fragment[%d] = TRUE \n", deq_turn_);                             
                        printf("fragment_inqueue[%d] = packetsize - capacity_bytes[%d] = %d, \n",
                                    deq_turn_,deq_turn_,fragment_inqueue[deq_turn_]);   
                    #endif                                                                    
                }
                
                /* If capacity becomes zero after previous dequeue, set non-segment */
                    
                else if (capacity_bytes[deq_turn_] == 0) {
                    
                    #ifdef Track_Round_Robin
                        printf("\n");
                        printf("slot_index = %d, \n",slot_index);
                        printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());
                        if (flag_fragment[deq_turn_] == TRUE) {
                            printf("HOL is a fragment, \n");
                        }
                        else {
                          printf("HOL is a whole packet, \n");
                        } 
                    #endif
                        
                    fragment_inqueue[deq_turn_] = 0 ;
                    flag_fragment[deq_turn_] = FALSE ;
                    
                    #ifdef Track_Round_Robin
                        printf("capacity_bytes[%d] = %d < packetsize = %d, \n",
                                deq_turn_,capacity_bytes[deq_turn_],packetsize);
                        printf("flag_fragment[%d] = FALSE \n", deq_turn_); 
                        printf("fragment_inqueue[%d] = %d, \n",
                                deq_turn_,fragment_inqueue[deq_turn_]);                                
                    #endif
                                                
                }
                
                flag_newframe = TRUE ;      flag_startframe = TRUE ;

                
                #ifdef Track_Round_Robin
                    printf("q_[%d]->length() = %d, \n",deq_turn_,q_[deq_turn_]->length());                
                    printf("deq_turn_ = %d --> ",deq_turn_);                
                #endif
                        
                deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);                

                #ifdef Track_Round_Robin
                    printf("deq_turn_ = %d, \n",deq_turn_);  
                #endif
                            
            }
            else {

                /* If capacity is less than zero, report error */ 
    
                printf("\n\n");   
                printf("Error: capacity_bytes < 0"); 
                exit(1);                     
            }
            
        }  // If find available queue 

    } // while(search_flag == FALSE)        


       /* Update statistics */

        if (flag_newframe == TRUE) {
        
            /* Update average throughput for non deq_turn_ queue */
            for(queue_index =0; queue_index < NUM_BS_QUEUES; queue_index++){
            
                if (queue_index != deq_turn_) {

                    #ifdef Track_Opportunistic
                        printf("avg_thrput[%d] = %f, ",queue_index,avg_thrput[queue_index]);
                    #endif 
                    
                    avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[queue_index]);
                    avg_thrput[queue_index] = avg_thr_next;
                    avg_thrput_record[trial_index][queue_index][slot_index] = avg_thr_next;
                    
                    #ifdef Track_Opportunistic
                        printf("-->avg_thrput[%d] = %f, \n",queue_index,avg_thrput[queue_index]);
                    #endif
                }
                        
            }
           

            /* Update throughput for deq_turn_ */                    

            int search_index = deq_turn_;
        
            if (search_index != start_index) {
            //if (flag_skip == FALSE) {
                
               #ifdef Track_Opportunistic 
               printf("\nsearch_index != start_index \n");
               printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
               printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
               printf("avg_thrput[%d] = %f, ",deq_turn_,avg_thrput[deq_turn_]);
               #endif 
                
               avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[deq_turn_]
                  +  EXP_THROUGHPUT_PARAM*(capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]) );
               avg_thrput[deq_turn_] = avg_thr_next;   // average throughput in the next slot
               avg_thrput_record[trial_index][deq_turn_][slot_index] = avg_thr_next;
                
               #ifdef Track_Opportunistic 
                    printf("--> avg_thrput[%d] = %f, \n\n",deq_turn_,avg_thrput[deq_turn_]);
               #endif                
            
               //printf("deq_turn_next = %d \n", deq_turn_);
               //printf("deq_turn = %d \n\n\n", ((deq_turn_ - 1) % NUM_BS_QUEUES));
            
               if (deq_turn_ != 0) {
                   deq_turn_ = ((deq_turn_ - 1) % NUM_BS_QUEUES);     
               }
               else {
                   deq_turn_ = NUM_BS_QUEUES - 1;                 
               }
            
                /* save schedule statistics in matrix */
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    sched_stat[trial_index][slot_index][0] = now;
                    sched_stat[trial_index][slot_index][1] = trial_index;
                    sched_stat[trial_index][slot_index][2] = slot_index;
                    sched_stat[trial_index][slot_index][3] = deq_turn_;
                    sched_stat[trial_index][slot_index][4] = 
                        (capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]);                    
                    sched_stat[trial_index][slot_index][5] = capacity_bytes_deq_turn_;
                    sched_stat[trial_index][slot_index][6] = avg_thrput[deq_turn_];
                    sched_stat[trial_index][slot_index][7] = -1; // metric[deq_turn_];                
                    sched_stat[trial_index][slot_index][8] = 
                            mode_record[trial_index][deq_turn_][slot_index];                            
                }
                
                deq_turn_ = ((deq_turn_ + 1) % NUM_BS_QUEUES);     
                
                
            }
            else {
                
                #ifdef Track_Opportunistic
                printf("\nsearch_index == start_index \n");
                printf("capacity_bytes_deq_turn_ = %d, \n",capacity_bytes_deq_turn_);
                printf("capacity_bytes[%d] = %d, \n",deq_turn_,capacity_bytes[deq_turn_]);
                printf("avg_thrput[%d] = %f, ",deq_turn_,avg_thrput[deq_turn_]);
                #endif 
                
                avg_thr_next = (double) ((1 - EXP_THROUGHPUT_PARAM)*avg_thrput[deq_turn_]);
                avg_thrput[deq_turn_] = avg_thr_next;   // average throughput in the next slot
                avg_thrput_record[trial_index][deq_turn_][slot_index] = avg_thr_next;
                
                #ifdef Track_Opportunistic
                printf("--> avg_thrput[%d] = %f, \n\n",deq_turn_,avg_thrput[deq_turn_]);            
                #endif
                
                /* save schedule statistics in matrix */
                if ( (trial_index < Num_Trial) && (slot_index < Num_Slot) ) {
                    sched_stat[trial_index][slot_index][0] = now;
                    sched_stat[trial_index][slot_index][1] = trial_index;
                    sched_stat[trial_index][slot_index][2] = slot_index;
                    sched_stat[trial_index][slot_index][3] = -1;
                    sched_stat[trial_index][slot_index][4] = 
                        (capacity_bytes_deq_turn_ - capacity_bytes[deq_turn_]);                    
                    sched_stat[trial_index][slot_index][5] = capacity_bytes_deq_turn_;
                    sched_stat[trial_index][slot_index][6] = avg_thrput[deq_turn_];
                    sched_stat[trial_index][slot_index][7] = -1; // metric[deq_turn_];                
                    sched_stat[trial_index][slot_index][8] = 
                            mode_record[trial_index][deq_turn_][slot_index];                                    
                }
                
            }
        }   


    /* Return null pointer if packet is not dequeued */
    if(pkt_dequed == FALSE)
        p = 0;

    return(p);
    
}

/**********************************************************
Check_New_Trial()

Check simulation time to start and initialize new trial
**********************************************************/

void Dot16BS::Check_New_Trial() {

    int queue_index;  // Index to loop over users/queues
    double now;       // Current simulation time
    
    now = Scheduler::instance().clock();

    /* Determine trial index based on simulation time */
    
    /* trial_index is the integer of current simulation time over the time per trial */
    trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);

    /* slot_index is the time-slot offset in current trial, which is the module 
       of the total number of slots over the number of slots per trial. */
    slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);    
           
    //printf("\ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);

        
    /* Print trial_index and update simulation parameters for new trial */

    if(0){
   // if (slot_index == Num_Slot - 1) {
    
        printf("\ntrial_index = %d, \t simulation_time = %f \n",trial_index, now);

        /* Reset avg_thrput for proportional fair scheduling */
        for(queue_index = 0; queue_index < NUM_BS_QUEUES; queue_index++){
            avg_thrput[queue_index] = 1.0; 
        }

        /* Initilization for Round Robin */
        deq_turn_ = 0;

        /* Initialization for fragmentation */
        flag_fragment[queue_index] = FALSE;    // Flag of fragmentation 
        fragment_bytes_inqueue[queue_index] = 0;    // Fragment (bytes) left in queue    
        
        /* Intialization for new frame */
        flag_newframe = TRUE;      // Flag of new frame   
        flag_startframe = FALSE;      

        /* Initialize capacity per frame */
        //capacity_bytes[queue_index] = (int) (4.5 * 50) ;    
        
        /* Initialize number of fragment of head of line packet left in queue */    
        fragment_inqueue[queue_index] = 0;            
        
    }
    
     
        
        /*if (trial_index == Num_Trial - 1 && slot_index == NumOfSlots_ - 1) {
                    
            //printf("before record: \ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);

            Record_Results_PF();   

            //printf("recorded ! \n");    
            //printf("after record: \ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);


            }   */  
        
       
        /* Finish simulation */ 
        if (slot_index >=  NumOfSlots_-1 ) { 
        
            if (now > last_record_time_ )
            {
                
                FILE *fp_Pkts = fopen("NumOfPkts.dat","a+");
                FILE *fp_Qlen = fopen("QLen.dat","a+");
                for (queue_index = 0; queue_index < Num_User; queue_index++)
                {
                    fprintf(fp_Pkts,"%d  ",num_sched_pkt[queue_index]);
                    fprintf(fp_Qlen,"%d  ",q_[queue_index]->length());
            
                }
                fprintf(fp_Pkts,"%.4f\n", now);
                fclose(fp_Pkts);
                fprintf(fp_Qlen,"%.4f\n", now);
                fclose(fp_Qlen);
                last_record_time_ = now;
            }
            
            //printf("\ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);
            //printf("\ntrial_index = %d, \t now = %f \n\n",trial_index,now);

                    
            printf("\n");

                               
            for (queue_index = 0; queue_index < NUM_BS_QUEUES; queue_index++) {
 
                printf("num_sched_pkt[user %d] = %d, \n",queue_index,num_sched_pkt[queue_index]);
                
            } 
            printf("\n");
            
            //printf("Dot16BS: The lastest data was recorded at %.6f sec\n",last_record_time_);
            printf("\nDot16BS.CC: Simulation Finished at %.6f sec \n\n",Scheduler::instance().clock());
            
        }
        if (slot_index >=  NumOfSlots_ + 1)//allow 2 more slots to record data.
        {
            printf("Dot16.cc: exit(0)............");
            exit(0);
        }


}

/**********************************************************
dump_results()

This procedure dumps various statistics from the Dot16BS
object into a file. Normally called at the completion of
the simulation.
**********************************************************/

void Dot16BS::dump_results()
{
    return;
}

int Dot16BS::command(int argc, const char*const* argv)
{
    if(strcmp(argv[1], "dump_results") == 0){
        dump_results();
        return(TCL_OK);
    }
    
    return(Queue::command(argc, argv));
}
      
/**********************************************************
Genarate_SNR_values()

This procedure gets nominal snr values from file and 
generate instantaneous snr values by Jake's model.
**********************************************************/

void Dot16BS::Genarate_SNR_values() {

    float random_phase[NUM_JAKES_SUBPATHS]; //random phase offset for subpaths
    float gain_real[NUM_JAKES_SUBPATHS];    //real component of gain
    float gain_imag[NUM_JAKES_SUBPATHS];    // imaginary component of gain
    float theta;                            // (2*pi*fd)

    int i;  // loop index
    double norm;                   // norm of channel gain 
    double real_h, imag_h, now;    // real and imagine component of channel gain
    float doppler;        // doppler value (Hz)  
    
    float snr;           
    float nominal_snr;
    float nominal_snr_db;

    doppler = doppler_;
    //printf("GENERATE_SNR: doppler = %.5f \n", doppler);

    FILE *fp_snr_dB_ns;    // pointer to the file of snr (dB) generated by ns
    
    /* Generate SNR by Jake's model */
    for(trial_index = 0; trial_index < Num_Trial; trial_index++){
        for(user_index = 0; user_index < Num_User; user_index++){

        /* Initialize parameters for Jakes model */
        for(i=0; i<NUM_JAKES_SUBPATHS; i++){
            random_phase[i] = cos(2*PI*(Random::uniform()));
            gain_real[i]    = Random::normal(0.0, 1.0);
            gain_imag[i]    = Random::normal(0.0, 1.0);
        }

        /* Normalize complex gain */
        norm = 0.0;
        for(i=0;i<NUM_JAKES_SUBPATHS; i++){ 
            norm += (gain_real[i]*gain_real[i] +
                         gain_imag[i]*gain_imag[i]);
        }
        norm = sqrt(norm);

        for(i=0;i<NUM_JAKES_SUBPATHS; i++){
            gain_real[i] /= norm;
            gain_imag[i] /= norm;
        }

        theta = 2*PI*doppler;
        /* Initialize parameters for Jakes model */

            nominal_snr_db = NominalSINRdB[user_index][trial_index];            
            nominal_snr = pow(10.0, (nominal_snr_db/10.0));

            for(slot_index = 0; slot_index < Num_Slot; slot_index++){
            
                /* Determine current simulation time */
                now = (slot_index)*SLOT_TIME;

                /* Vary SNR according to Jakes model */
                real_h = 0.0;
                imag_h = 0.0;
    
                for(i=0; i<NUM_JAKES_SUBPATHS; i++){//lzq: (gain_real - j*gain_imag) * (cos+j*sin)

                    real_h += gain_real[i]*cos(theta*random_phase[i]*now) 
                            + gain_imag[i]*sin(theta*random_phase[i]*now);

                    imag_h += gain_real[i]*sin(theta*random_phase[i]*now) 
                            - gain_imag[i]*cos(theta*random_phase[i]*now);

                }

                snr = nominal_snr * (real_h*real_h + imag_h*imag_h);
                           
                /* Save SNR (dB) values in matrix */           
                snr_dB_value[trial_index][user_index][slot_index] = 10*log10(snr);
                
            }
        }
    }            

    /* Record SNR (dB) values to file */
    fp_snr_dB_ns = fopen("snr.txt","a");
        
    for(trial_index = 0; trial_index < Num_Trial; trial_index++){
        for(user_index = 0; user_index < Num_User; user_index++){
            for(slot_index = 0; slot_index < Num_Slot; slot_index++){

                fprintf(fp_snr_dB_ns, "%f ", snr_dB_value[trial_index][user_index][slot_index]);

            }
            fprintf(fp_snr_dB_ns, "\n");
        }
        fprintf(fp_snr_dB_ns, "\n");
    }
   fclose(fp_snr_dB_ns);

}

/**********************************************************
Record_Sched_Stat(sel_queue,sel_rate); 

This procedure record scheduled user and rate to file.
**********************************************************/

void Dot16BS::Record_Sched_Stat(int sel_queue, float sel_rate) {

        double now;     // Current simulation time
        FILE *fp_sched;     // pointer to the file of recording scheduled queue
        FILE *fp_thrput;     // pointer to the file of recording throughput
        
        now = Scheduler::instance().clock();
        
        /* trial_index is the integer of current simulation time over the time per trial */
        trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);

        /* slot_index is the time-slot offset in current trial, which is the module 
           of the total number of slots over the number of slots per trial. */
        slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);

        /* save schedule statistics in matrix */
        sched_stat[trial_index][slot_index][0] = sel_queue;
        sched_stat[trial_index][slot_index][1] = now;
        sched_stat[trial_index][slot_index][2] = sel_rate;     
    
        /* record schedule statistics in file when simulation is finished */
        if ((trial_index == Num_Trial-1) && (slot_index == Num_Slot-1)) {

            fp_sched = fopen("sched_statistics.out","a+");
            for(trial_index =0; trial_index < Num_Trial; trial_index++){
                for(slot_index =0; slot_index < Num_Slot; slot_index++) {

                    /* Print scheduled queue, time and rate info to file */
                    fprintf(fp_sched, "%f\t %f\t %f \n", sched_stat[trial_index][slot_index][0],
                                sched_stat[trial_index][slot_index][1],                                               
                                sched_stat[trial_index][slot_index][2]);

                    /* Print throughput info to file */
                    fp_thrput = fopen("thrput_statistics.out","a+");
                    for(user_index =0; user_index < Num_User; user_index++) {
                        fprintf(fp_thrput, "%d\t %f\t %f \n", user_index, now, 
                        avg_thrput_record[trial_index][user_index][slot_index]);
                    }

                }
            }
            fclose(fp_sched);           
            fclose(fp_thrput);
        }
}
 
 
/**********************************************************
Record_Results_PF() ; 

This procedure record scheduling statistics.
**********************************************************/

void Dot16BS::Record_Results_PF() {

    double now;    
    now = Scheduler::instance().clock();
    
    FILE *fp_sched;     // pointer to the file of recording scheduled queue
    FILE *fp_metric;     // pointer to the file of recording scheduled queue



     fp_metric = fopen("metric_record.txt","w");
     fclose(fp_metric);                        

     fp_sched = fopen("sched_statistics.txt","w");
     fclose(fp_sched);                        

     //printf("start record: \ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);


    
            for(trial_index =0; trial_index < Num_Trial; trial_index++){
            
                for(slot_index =0; slot_index < Num_Slot; slot_index++) {
                
                    fp_sched = fopen("sched_statistics.txt","a+");

                    fprintf(fp_sched, "%f\t%d\t%d\t%d\t%d\t%d\t%f\t%f\t%d\n", 
                                sched_stat[trial_index][slot_index][0],
                             (int)   sched_stat[trial_index][slot_index][1],                                               
                             (int)   sched_stat[trial_index][slot_index][2],
                             (int)   sched_stat[trial_index][slot_index][3],
                             (int)   sched_stat[trial_index][slot_index][4],
                             (int)   sched_stat[trial_index][slot_index][5],
                                     sched_stat[trial_index][slot_index][6],
                                     sched_stat[trial_index][slot_index][7],
                             (int)   sched_stat[trial_index][slot_index][8]);                                  ;
    
                    fclose(fp_sched);                        
                    
                    fp_metric = fopen("metric_record.txt","a+");
                    
                    for(user_index =0; user_index < Num_User; user_index++) {

                        /*
                        printf("metric_record[%d][%d][%d] = %f, \n",
                            trial_index,user_index,slot_index,
                            metric_record[trial_index][user_index][slot_index]);
                        */
                                            
                        fprintf(fp_sched, "%d\t%d\t%d\t%d\t%d\t%f\t%f\t%f\n",     
                            trial_index, 
                            slot_index, 
                            user_index,
                            mode_record[trial_index][user_index][slot_index],                            
                            capacity_record[trial_index][user_index][slot_index],
                            avg_thrput_record[trial_index][user_index][slot_index],
                            metric_record[trial_index][user_index][slot_index],
                            snr_dB_value[trial_index][user_index][slot_index]) ;

                    }
                    fclose(fp_metric);      
                
                }
                
            }
            
        /* trial_index is the integer of current simulation time over the time per trial */
        trial_index = (int) floor(now/(SLOT_TIME)/Num_Slot);

        /* slot_index is the time-slot offset in current trial, which is the module 
           of the total number of slots over the number of slots per trial. */
        slot_index = (int) ((int) (floor(now/(SLOT_TIME))) % Num_Slot);
                    
        //printf("end record: \ntrial_index = %d, slot_index = %d \t now = %f \n\n",trial_index,slot_index, now);
            

}


 Packet* Dot16BS::PktGen()
 {
    Packet *p_New;
    hdr_ip* iph_New;
    p_New = Packet::alloc();
    iph_New = hdr_ip::access(p_New);
    iph_New->fid_ = 1000;
    
    iph_New->src_.addr_ = 3;
    iph_New->src_.port_ = 0; 
    iph_New->dst_.addr_ = 4; 
    iph_New->dst_.port_ = 0;
    return(p_New);
}
   
  
 
